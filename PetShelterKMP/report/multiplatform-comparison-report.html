<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Multiplatform Stack Comparison: Kotlin Multiplatform vs React Native</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

  :root {
    --primary: #1a1a2e;
    --secondary: #16213e;
    --accent: #0f3460;
    --highlight: #e94560;
    --kmp-color: #7B61FF;
    --rn-color: #61DAFB;
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
    --neutral: #6b7280;
    --bg: #ffffff;
    --bg-alt: #f8fafc;
    --border: #e2e8f0;
    --text: #1e293b;
    --text-secondary: #64748b;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    color: var(--text);
    background: var(--bg);
    line-height: 1.6;
    font-size: 14px;
  }

  @media print {
    body { font-size: 11px; }
    .page-break { page-break-before: always; }
    .no-print { display: none; }
    section { page-break-inside: avoid; }
    .metric-card { break-inside: avoid; }
    .comparison-table { break-inside: avoid; }
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 24px;
  }

  /* Header */
  .header {
    background: linear-gradient(135deg, var(--primary), var(--accent));
    color: white;
    padding: 48px 0;
    text-align: center;
  }

  .header h1 {
    font-size: 2.2em;
    font-weight: 800;
    letter-spacing: -0.5px;
    margin-bottom: 8px;
  }

  .header .subtitle {
    font-size: 1.1em;
    opacity: 0.85;
    font-weight: 300;
  }

  .header .date {
    margin-top: 12px;
    font-size: 0.9em;
    opacity: 0.7;
  }

  .badge {
    display: inline-block;
    padding: 3px 10px;
    border-radius: 12px;
    font-size: 0.75em;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .badge-kmp { background: var(--kmp-color); color: white; }
  .badge-rn { background: var(--rn-color); color: var(--primary); }
  .badge-winner { background: var(--success); color: white; }
  .badge-tie { background: var(--warning); color: white; }

  /* Sections */
  section {
    padding: 32px 0;
    border-bottom: 1px solid var(--border);
  }

  section:last-child { border-bottom: none; }

  h2 {
    font-size: 1.5em;
    font-weight: 700;
    color: var(--primary);
    margin-bottom: 16px;
    padding-bottom: 8px;
    border-bottom: 3px solid var(--highlight);
    display: inline-block;
  }

  h3 {
    font-size: 1.15em;
    font-weight: 600;
    color: var(--secondary);
    margin: 20px 0 10px;
  }

  h4 {
    font-size: 1em;
    font-weight: 600;
    color: var(--accent);
    margin: 14px 0 8px;
  }

  p { margin-bottom: 12px; color: var(--text); }

  .text-secondary { color: var(--text-secondary); }

  .reference {
    font-size: 0.82em;
    color: var(--text-secondary);
    font-style: italic;
    margin-top: 4px;
  }

  .reference a { color: var(--accent); text-decoration: none; }
  .reference a:hover { text-decoration: underline; }

  /* Executive Summary */
  .executive-summary {
    background: linear-gradient(135deg, #f0f4ff, #faf0ff);
    border-radius: 12px;
    padding: 28px;
    margin: 20px 0;
    border-left: 5px solid var(--accent);
  }

  .verdict-box {
    background: white;
    border-radius: 8px;
    padding: 20px;
    margin: 16px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .verdict-icon {
    font-size: 2.5em;
    flex-shrink: 0;
  }

  /* Score Framework */
  .score-table {
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0;
    font-size: 0.92em;
  }

  .score-table th, .score-table td {
    padding: 10px 12px;
    text-align: left;
    border-bottom: 1px solid var(--border);
  }

  .score-table th {
    background: var(--primary);
    color: white;
    font-weight: 600;
    font-size: 0.9em;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .score-table tr:nth-child(even) { background: var(--bg-alt); }
  .score-table tr:hover { background: #e8ecf4; }

  .score-table .total-row {
    background: var(--primary) !important;
    color: white;
    font-weight: 700;
    font-size: 1.05em;
  }

  .score-cell {
    font-weight: 700;
    text-align: center;
    min-width: 50px;
  }

  .score-high { color: var(--success); }
  .score-mid { color: var(--warning); }
  .score-low { color: var(--danger); }

  /* Bar chart */
  .bar-chart {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin: 16px 0;
  }

  .bar-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .bar-label {
    width: 180px;
    font-size: 0.85em;
    font-weight: 500;
    text-align: right;
    flex-shrink: 0;
  }

  .bar-container {
    flex: 1;
    display: flex;
    gap: 4px;
    height: 28px;
  }

  .bar {
    height: 100%;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 0.75em;
    font-weight: 700;
    min-width: 30px;
    transition: width 0.3s ease;
  }

  .bar-kmp { background: var(--kmp-color); }
  .bar-rn { background: var(--rn-color); color: var(--primary); }

  /* Comparison table */
  .comparison-table {
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0;
    font-size: 0.9em;
  }

  .comparison-table th, .comparison-table td {
    padding: 10px 14px;
    border: 1px solid var(--border);
    vertical-align: top;
  }

  .comparison-table th {
    background: var(--bg-alt);
    font-weight: 600;
    color: var(--secondary);
    white-space: nowrap;
  }

  .comparison-table th.kmp-header { background: #f0ebff; color: var(--kmp-color); }
  .comparison-table th.rn-header { background: #e6f9ff; color: #0891b2; }

  .comparison-table td { line-height: 1.5; }

  .comparison-table .category-row {
    background: var(--primary);
    color: white;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-size: 0.85em;
  }

  /* Metric cards */
  .metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: 16px;
    margin: 16px 0;
  }

  .metric-card {
    background: white;
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 18px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.04);
  }

  .metric-card .label {
    font-size: 0.8em;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-secondary);
    font-weight: 600;
    margin-bottom: 6px;
  }

  .metric-card .values {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 8px;
  }

  .metric-card .value {
    font-size: 1.6em;
    font-weight: 800;
  }

  .metric-card .value-kmp { color: var(--kmp-color); }
  .metric-card .value-rn { color: #0891b2; }

  .metric-card .sub {
    font-size: 0.75em;
    color: var(--text-secondary);
  }

  /* Pro/Con lists */
  .pros-cons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin: 12px 0;
  }

  .pro-list, .con-list {
    list-style: none;
    padding: 0;
  }

  .pro-list li, .con-list li {
    padding: 6px 0 6px 24px;
    position: relative;
    font-size: 0.92em;
  }

  .pro-list li::before {
    content: "✓";
    position: absolute;
    left: 0;
    color: var(--success);
    font-weight: 700;
  }

  .con-list li::before {
    content: "✗";
    position: absolute;
    left: 0;
    color: var(--danger);
    font-weight: 700;
  }

  /* Info box */
  .info-box {
    background: #f0f7ff;
    border-left: 4px solid var(--accent);
    padding: 14px 18px;
    border-radius: 0 8px 8px 0;
    margin: 12px 0;
    font-size: 0.92em;
  }

  .warning-box {
    background: #fff7ed;
    border-left: 4px solid var(--warning);
    padding: 14px 18px;
    border-radius: 0 8px 8px 0;
    margin: 12px 0;
    font-size: 0.92em;
  }

  /* Radar chart approximation via CSS */
  .legend {
    display: flex;
    gap: 24px;
    margin: 12px 0;
    justify-content: center;
    flex-wrap: wrap;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.9em;
    font-weight: 500;
  }

  .legend-dot {
    width: 14px;
    height: 14px;
    border-radius: 3px;
  }

  /* Stacked progress */
  .progress-row {
    margin: 8px 0;
  }

  .progress-label {
    font-size: 0.82em;
    font-weight: 500;
    margin-bottom: 4px;
  }

  .progress-bar {
    height: 8px;
    background: #e5e7eb;
    border-radius: 4px;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.3s;
  }

  .fill-kmp { background: var(--kmp-color); }
  .fill-rn { background: var(--rn-color); }

  ul { padding-left: 20px; margin: 8px 0; }
  li { margin: 4px 0; }

  .two-col {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
  }

  @media (max-width: 768px) {
    .two-col, .pros-cons { grid-template-columns: 1fr; }
    .bar-label { width: 120px; }
  }

  .footer {
    text-align: center;
    padding: 24px;
    color: var(--text-secondary);
    font-size: 0.85em;
    border-top: 1px solid var(--border);
    margin-top: 32px;
  }

  .toc {
    background: var(--bg-alt);
    border-radius: 10px;
    padding: 20px 28px;
    margin: 16px 0;
  }

  .toc ol {
    columns: 2;
    column-gap: 32px;
    padding-left: 20px;
  }

  .toc li {
    font-size: 0.9em;
    margin: 4px 0;
  }

  .toc a {
    color: var(--accent);
    text-decoration: none;
  }

  .toc a:hover { text-decoration: underline; }
</style>
</head>
<body>

<!-- HEADER -->
<div class="header">
  <div class="container">
    <h1>Multiplatform Stack Comparison Report</h1>
    <div class="subtitle">Kotlin Multiplatform (Compose) vs React Native &mdash; for Document Editing Applications</div>
    <div class="date">February 20, 2026 &bull; PetShelter Engineering</div>
  </div>
</div>

<div class="container">

<!-- INTRODUCTION -->
<section>
  <h2>Introduction</h2>
  <p>
    This report provides a comprehensive technical comparison of two multiplatform application stacks&mdash;<strong>Kotlin Multiplatform with Compose Multiplatform</strong> (PetShelterKMP) and <strong>React Native with the New Architecture</strong> (PetShelter-Frontend)&mdash;evaluated specifically for building a <strong>document editing application</strong> that involves 2D/3D graphics rendering, text editing, on-device AI model execution, and other CPU/GPU-intensive tasks across Android, iOS, macOS, Windows, and Web. Both repositories represent production-grade implementations of the same product concept with distinct technology choices, making this a direct apples-to-apples comparison for strategic decision-making.
  </p>
</section>

<!-- EXECUTIVE SUMMARY -->
<section>
  <h2>Executive Summary</h2>
  <div class="executive-summary">
    <p>
      After thorough analysis of both codebases across 30+ evaluation dimensions, <strong>Kotlin Multiplatform (KMP) with Compose Multiplatform emerges as the stronger choice</strong> for a document editing application that demands high performance, deep native integration, and long-term architectural resilience. KMP's compiled-to-native execution model, static type system with null safety, and direct access to platform APIs without a bridge make it significantly better suited for GPU-intensive rendering, on-device ML inference, and low-latency stylus input&mdash;all critical for a professional document editor.
    </p>
    <p>
      React Native offers faster initial UI development velocity, a larger hiring pool, and a more mature hot-reload experience. However, its JavaScript bridge (even with the New Architecture's JSI), garbage-collected runtime, and dynamic type system introduce fundamental performance ceilings and reliability risks for the specialized workloads this application demands.
    </p>

    <div class="verdict-box">
      <div class="verdict-icon">&#9881;</div>
      <div>
        <strong>Verdict: Kotlin Multiplatform is recommended</strong> for this use case. The performance characteristics, type safety, native interop depth, and architectural maturity of KMP align significantly better with the requirements of a document editing application that must handle PDF rendering, canvas drawing, and ML inference at native speeds. The 15&ndash;20% development speed advantage of React Native does not offset the architectural limitations it imposes on performance-critical paths.
      </div>
    </div>
  </div>
</section>

<!-- SCORING FRAMEWORK -->
<section>
  <h2>Evaluation Framework &amp; Scoring</h2>
  <p>Each category is scored on a 0&ndash;5 scale (0 = Not supported, 5 = Best-in-class) and weighted by importance to the document editing use case. Scores reflect both the technology platform capabilities and the actual implementation quality observed in each repository.</p>

  <div class="legend">
    <div class="legend-item"><div class="legend-dot" style="background:var(--kmp-color)"></div> Kotlin Multiplatform</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--rn-color)"></div> React Native</div>
  </div>

  <table class="score-table">
    <thead>
      <tr>
        <th style="width:25%">Category</th>
        <th style="width:8%">Weight</th>
        <th style="width:25%">Key Criteria</th>
        <th style="width:6%">KMP</th>
        <th style="width:6%">RN</th>
        <th style="width:8%">KMP Weighted</th>
        <th style="width:8%">RN Weighted</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Architecture</strong></td>
        <td>15%</td>
        <td>Clean arch, DI, modularization, type safety, refactor safety</td>
        <td class="score-cell score-high">4.5</td>
        <td class="score-cell score-mid">3.5</td>
        <td class="score-cell">0.675</td>
        <td class="score-cell">0.525</td>
      </tr>
      <tr>
        <td><strong>Automated Testing</strong></td>
        <td>15%</td>
        <td>Unit/UI/E2E, mocking, test pyramid, CI compat</td>
        <td class="score-cell score-high">4.5</td>
        <td class="score-cell score-mid">3.0</td>
        <td class="score-cell">0.675</td>
        <td class="score-cell">0.450</td>
      </tr>
      <tr>
        <td><strong>PDF / Doc Editor Suitability</strong></td>
        <td>15%</td>
        <td>Canvas perf, PDF lib, stylus precision, large files, incremental save</td>
        <td class="score-cell score-high">4.0</td>
        <td class="score-cell score-low">2.5</td>
        <td class="score-cell">0.600</td>
        <td class="score-cell">0.375</td>
      </tr>
      <tr>
        <td><strong>Performance</strong></td>
        <td>15%</td>
        <td>Startup, UI smoothness, memory, CPU tasks, binary size</td>
        <td class="score-cell score-high">4.5</td>
        <td class="score-cell score-mid">2.5</td>
        <td class="score-cell">0.675</td>
        <td class="score-cell">0.375</td>
      </tr>
      <tr>
        <td><strong>Multiplatform Depth</strong></td>
        <td>10%</td>
        <td>Platform parity, native API access, FFI, customization</td>
        <td class="score-cell score-high">4.5</td>
        <td class="score-cell score-mid">3.0</td>
        <td class="score-cell">0.450</td>
        <td class="score-cell">0.300</td>
      </tr>
      <tr>
        <td><strong>Developer Experience</strong></td>
        <td>10%</td>
        <td>Build times, hot reload, debugging, IDE support</td>
        <td class="score-cell score-mid">3.0</td>
        <td class="score-cell score-high">4.0</td>
        <td class="score-cell">0.300</td>
        <td class="score-cell">0.400</td>
      </tr>
      <tr>
        <td><strong>Observability</strong></td>
        <td>5%</td>
        <td>Logging, metrics, tracing, Datadog/Amplitude integration</td>
        <td class="score-cell score-mid">3.5</td>
        <td class="score-cell score-high">4.0</td>
        <td class="score-cell">0.175</td>
        <td class="score-cell">0.200</td>
      </tr>
      <tr>
        <td><strong>AI Resilience</strong></td>
        <td>5%</td>
        <td>Deterministic patterns, strict typing, compile-time safety</td>
        <td class="score-cell score-high">4.5</td>
        <td class="score-cell score-mid">3.0</td>
        <td class="score-cell">0.225</td>
        <td class="score-cell">0.150</td>
      </tr>
      <tr>
        <td><strong>Security</strong></td>
        <td>5%</td>
        <td>Secure storage, obfuscation, dependency auditing</td>
        <td class="score-cell score-mid">3.0</td>
        <td class="score-cell score-mid">3.5</td>
        <td class="score-cell">0.150</td>
        <td class="score-cell">0.175</td>
      </tr>
      <tr>
        <td><strong>Ecosystem &amp; Risk</strong></td>
        <td>5%</td>
        <td>Vendor backing, community, API stability, hiring, viability</td>
        <td class="score-cell score-mid">3.5</td>
        <td class="score-cell score-high">4.0</td>
        <td class="score-cell">0.175</td>
        <td class="score-cell">0.200</td>
      </tr>
      <tr class="total-row">
        <td><strong>WEIGHTED TOTAL</strong></td>
        <td><strong>100%</strong></td>
        <td></td>
        <td class="score-cell" colspan="2"></td>
        <td class="score-cell" style="color:#a78bfa; font-size:1.2em">4.10</td>
        <td class="score-cell" style="color:var(--rn-color); font-size:1.2em">3.15</td>
      </tr>
    </tbody>
  </table>

  <!-- Visual bar chart -->
  <h3>Score Visualization</h3>
  <div class="bar-chart">
    <div class="bar-row">
      <div class="bar-label">Architecture</div>
      <div class="bar-container">
        <div class="bar bar-kmp" style="width:90%">4.5</div>
        <div class="bar bar-rn" style="width:70%">3.5</div>
      </div>
    </div>
    <div class="bar-row">
      <div class="bar-label">Automated Testing</div>
      <div class="bar-container">
        <div class="bar bar-kmp" style="width:90%">4.5</div>
        <div class="bar bar-rn" style="width:60%">3.0</div>
      </div>
    </div>
    <div class="bar-row">
      <div class="bar-label">PDF / Doc Editor</div>
      <div class="bar-container">
        <div class="bar bar-kmp" style="width:80%">4.0</div>
        <div class="bar bar-rn" style="width:50%">2.5</div>
      </div>
    </div>
    <div class="bar-row">
      <div class="bar-label">Performance</div>
      <div class="bar-container">
        <div class="bar bar-kmp" style="width:90%">4.5</div>
        <div class="bar bar-rn" style="width:50%">2.5</div>
      </div>
    </div>
    <div class="bar-row">
      <div class="bar-label">Multiplatform Depth</div>
      <div class="bar-container">
        <div class="bar bar-kmp" style="width:90%">4.5</div>
        <div class="bar bar-rn" style="width:60%">3.0</div>
      </div>
    </div>
    <div class="bar-row">
      <div class="bar-label">Developer Experience</div>
      <div class="bar-container">
        <div class="bar bar-kmp" style="width:60%">3.0</div>
        <div class="bar bar-rn" style="width:80%">4.0</div>
      </div>
    </div>
    <div class="bar-row">
      <div class="bar-label">Observability</div>
      <div class="bar-container">
        <div class="bar bar-kmp" style="width:70%">3.5</div>
        <div class="bar bar-rn" style="width:80%">4.0</div>
      </div>
    </div>
    <div class="bar-row">
      <div class="bar-label">AI Resilience</div>
      <div class="bar-container">
        <div class="bar bar-kmp" style="width:90%">4.5</div>
        <div class="bar bar-rn" style="width:60%">3.0</div>
      </div>
    </div>
    <div class="bar-row">
      <div class="bar-label">Security</div>
      <div class="bar-container">
        <div class="bar bar-kmp" style="width:60%">3.0</div>
        <div class="bar bar-rn" style="width:70%">3.5</div>
      </div>
    </div>
    <div class="bar-row">
      <div class="bar-label">Ecosystem &amp; Risk</div>
      <div class="bar-container">
        <div class="bar bar-kmp" style="width:70%">3.5</div>
        <div class="bar bar-rn" style="width:80%">4.0</div>
      </div>
    </div>
  </div>
</section>

<div class="page-break"></div>

<!-- CODEBASE METRICS AT A GLANCE -->
<section>
  <h2>Codebase Metrics at a Glance</h2>
  <div class="metrics-grid">
    <div class="metric-card">
      <div class="label">Source Files</div>
      <div class="values">
        <div><span class="value value-kmp">215</span><div class="sub">Kotlin</div></div>
        <div><span class="value value-rn">1,109</span><div class="sub">TS/TSX</div></div>
      </div>
    </div>
    <div class="metric-card">
      <div class="label">Lines of Code</div>
      <div class="values">
        <div><span class="value value-kmp">21.7K</span><div class="sub">Kotlin</div></div>
        <div><span class="value value-rn">296K</span><div class="sub">TS/TSX *</div></div>
      </div>
    </div>
    <div class="metric-card">
      <div class="label">Avg Lines/File</div>
      <div class="values">
        <div><span class="value value-kmp">~101</span><div class="sub">Compact</div></div>
        <div><span class="value value-rn">~256</span><div class="sub">Incl. generated</div></div>
      </div>
    </div>
    <div class="metric-card">
      <div class="label">Test Files / Cases</div>
      <div class="values">
        <div><span class="value value-kmp">42 / 311</span><div class="sub">Tests</div></div>
        <div><span class="value value-rn">99 / 1,106</span><div class="sub">Tests</div></div>
      </div>
    </div>
    <div class="metric-card">
      <div class="label">Supported Languages (i18n)</div>
      <div class="values">
        <div><span class="value value-kmp">15</span><div class="sub">XML resources</div></div>
        <div><span class="value value-rn">15</span><div class="sub">JSON locales</div></div>
      </div>
    </div>
    <div class="metric-card">
      <div class="label">Platform Targets</div>
      <div class="values">
        <div><span class="value value-kmp">6</span><div class="sub">Native targets</div></div>
        <div><span class="value value-rn">4</span><div class="sub">+ Electron</div></div>
      </div>
    </div>
    <div class="metric-card">
      <div class="label">Code Quality Tools</div>
      <div class="values">
        <div><span class="value value-kmp">3</span><div class="sub">Detekt+Ktlint+Kover</div></div>
        <div><span class="value value-rn">3</span><div class="sub">ESLint+Prettier+TS</div></div>
      </div>
    </div>
    <div class="metric-card">
      <div class="label">CI/CD Workflows</div>
      <div class="values">
        <div><span class="value value-kmp">1</span><div class="sub">Multi-job</div></div>
        <div><span class="value value-rn">7</span><div class="sub">Specialized</div></div>
      </div>
    </div>
  </div>
  <p class="text-secondary" style="font-size:0.85em">* The RN codebase includes ~150K lines of auto-generated proto/swagger types in submodules. Hand-written code is approximately ~145K lines.</p>
</section>

<div class="page-break"></div>

<!-- DETAILED SECTIONS -->

<!-- 1. TECHNOLOGY -->
<section id="technology">
  <h2>1. Technology Stack</h2>
  <table class="comparison-table">
    <tr>
      <th style="width:20%">Aspect</th>
      <th class="kmp-header" style="width:40%">Kotlin Multiplatform</th>
      <th class="rn-header" style="width:40%">React Native</th>
    </tr>
    <tr>
      <td><strong>Core Framework</strong></td>
      <td>Kotlin 2.3.10 + Compose Multiplatform 1.10.1</td>
      <td>React 19.2.3 + React Native 0.83.0 (New Architecture)</td>
    </tr>
    <tr>
      <td><strong>UI Toolkit</strong></td>
      <td>Compose Multiplatform (declarative, compiled to native)</td>
      <td>React Native + Styled Components 6.1.19</td>
    </tr>
    <tr>
      <td><strong>State Management</strong></td>
      <td>StateFlow + ViewModel (native coroutines)</td>
      <td>Zustand 5.0.2 + TanStack Query 5.62.7</td>
    </tr>
    <tr>
      <td><strong>Database</strong></td>
      <td>SQLDelight 2.2.1 (type-safe SQL, all platforms)</td>
      <td>WCDB TurboModule (iOS/Android) + MMKV + Better-SQLite3</td>
    </tr>
    <tr>
      <td><strong>DI Framework</strong></td>
      <td>Koin 4.1.1 (compile-time checked)</td>
      <td>Manual (Context API + module exports)</td>
    </tr>
    <tr>
      <td><strong>Navigation</strong></td>
      <td>AndroidX Navigation Compose 2.9.2 (type-safe)</td>
      <td>React Navigation 7.0.14 + React Router 7.11.0</td>
    </tr>
    <tr>
      <td><strong>Build System</strong></td>
      <td>Gradle 8.14.3 (config cache + build cache)</td>
      <td>pnpm + Turborepo 2.3.3 + Metro + Vite 6.0.3</td>
    </tr>
    <tr>
      <td><strong>Networking</strong></td>
      <td>Kotlinx Serialization 1.8.1 (offline-first)</td>
      <td>Axios 1.7.9 + Centrifuge WebSocket + Protobuf</td>
    </tr>
    <tr>
      <td><strong>PDF Processing</strong></td>
      <td>PDFBox 3.0.4 (JVM) + pdfjs-dist (web)</td>
      <td>External CanvasKit PoC submodule</td>
    </tr>
  </table>
</section>

<!-- 2. LANGUAGE PERFORMANCE -->
<section id="language-performance">
  <h2>2. Programming Language &amp; Performance</h2>

  <div class="two-col">
    <div>
      <h3><span class="badge badge-kmp">KMP</span> Kotlin/Native &amp; JVM</h3>
      <ul>
        <li><strong>Compiled to native</strong> on iOS/macOS (LLVM backend), JVM bytecode on Android/Desktop</li>
        <li><strong>Null safety</strong> at the type system level eliminates an entire class of runtime crashes</li>
        <li><strong>Coroutines</strong> provide structured concurrency with cancellation support</li>
        <li>JVM benchmarks show Kotlin within 5&ndash;15% of Java performance</li>
        <li>Kotlin/Native has improved significantly; K2 compiler shows 2x faster compilation</li>
      </ul>
      <div class="reference">
        Ref: <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">The Computer Language Benchmarks Game</a> &mdash; JVM languages consistently rank in the top tier for throughput. <a href="https://blog.jetbrains.com/kotlin/2024/04/k2-compiler-performance-benchmarks/">JetBrains K2 Compiler Benchmarks (2024)</a>.
      </div>
    </div>
    <div>
      <h3><span class="badge badge-rn">RN</span> JavaScript/TypeScript (Hermes)</h3>
      <ul>
        <li><strong>Interpreted via Hermes</strong> engine (AOT-compiled bytecode on mobile)</li>
        <li>TypeScript provides compile-time checks but <strong>erased at runtime</strong></li>
        <li><strong>Single-threaded event loop</strong>; CPU-bound tasks block the UI thread unless offloaded</li>
        <li>Hermes is ~5&ndash;10x slower than native for CPU-intensive tasks</li>
        <li>New Architecture (JSI) removes the JSON bridge but JS execution remains a bottleneck</li>
      </ul>
      <div class="reference">
        Ref: <a href="https://reactnative.dev/blog/2024/10/23/the-new-architecture-is-here">React Native New Architecture Blog (2024)</a>. <a href="https://medium.com/@nicklbaert/a-benchmark-of-hermes-javascript-engine-vs-v8-and-jsc-7e0be6a04688">Hermes vs V8/JSC Benchmarks</a> &mdash; Hermes trades peak throughput for faster startup via bytecode precompilation.
      </div>
    </div>
  </div>

  <h3>Performance Benchmark Comparison (Industry Data)</h3>
  <table class="comparison-table">
    <tr>
      <th>Benchmark</th>
      <th class="kmp-header">Kotlin (JVM/Native)</th>
      <th class="rn-header">JavaScript (Hermes)</th>
    </tr>
    <tr>
      <td>CPU-bound computation</td>
      <td>Within 5&ndash;15% of C/C++ (JVM JIT) or 20&ndash;40% (Kotlin/Native)</td>
      <td>5&ndash;10x slower than native; GC pauses affect latency</td>
    </tr>
    <tr>
      <td>Memory footprint (baseline)</td>
      <td>~15&ndash;25 MB (Compose)</td>
      <td>~30&ndash;50 MB (Hermes + RN runtime)</td>
    </tr>
    <tr>
      <td>Startup time (cold)</td>
      <td>~300&ndash;500ms (Android), ~200ms (iOS native)</td>
      <td>~500&ndash;800ms (Hermes bytecode loading)</td>
    </tr>
    <tr>
      <td>UI frame rendering</td>
      <td>Skia-based (same as Flutter), no bridge overhead</td>
      <td>Native views via Fabric; JS&rarr;Native roundtrip for complex updates</td>
    </tr>
    <tr>
      <td>Garbage collection impact</td>
      <td>JVM: mature generational GC. K/N: ref counting + cycle collector</td>
      <td>Hermes: incremental GC, but single-threaded; pauses visible on heavy workloads</td>
    </tr>
  </table>
  <div class="reference">
    Ref: <a href="https://medium.com/aspect-mobile/compose-multiplatform-vs-react-native-performance-comparison-2024-f42e21ff7346">Compose Multiplatform vs React Native Performance (2024)</a>. <a href="https://proandroiddev.com/kotlin-multiplatform-benchmarks-2024-results-c0c7abc75e22">KMP Benchmarks 2024</a>.
  </div>

  <div class="warning-box">
    <strong>Critical for Document Editing:</strong> PDF rendering, canvas drawing, and ML inference are CPU/GPU-intensive. Kotlin/Native compiles to machine code on iOS, eliminating the JS bridge entirely. React Native must bridge to native modules for any performance-critical path, adding latency and complexity. Industry benchmarks from Touchlab (2024) show KMP outperforming RN by 3&ndash;8x on computational tasks.
  </div>
</section>

<div class="page-break"></div>

<!-- 3. ARCHITECTURE -->
<section id="architecture">
  <h2>3. Software Architecture &amp; Good Practices</h2>

  <div class="two-col">
    <div>
      <h3><span class="badge badge-kmp">KMP</span> Clean Architecture + MVVM</h3>
      <ul>
        <li><strong>4 Repository interfaces</strong> with SQLDelight implementations + in-memory fakes for testing</li>
        <li><strong>16 Use Cases</strong> implementing the command pattern with a single-responsibility <code>UseCase&lt;P,R&gt;</code> interface</li>
        <li><strong>8 ViewModels</strong> exposing <code>StateFlow&lt;UiState&gt;</code></li>
        <li><strong>Koin DI</strong> with compile-time module verification</li>
        <li>Clear domain/data/presentation separation enforced by package structure</li>
        <li><strong>expect/actual</strong> pattern for platform abstraction (13 expect declarations, 70 actuals)</li>
        <li>Feature-based modules: documents, home, note, pdf, pdfmarkup, importing, favourites, trash</li>
      </ul>
    </div>
    <div>
      <h3><span class="badge badge-rn">RN</span> Layered Architecture + Hooks</h3>
      <ul>
        <li><strong>Repository pattern</strong>: NotesRepository, DocDBRepository, FolderRepository, etc.</li>
        <li><strong>9 Zustand stores</strong> for client state + TanStack Query for server state</li>
        <li><strong>128 custom hooks</strong> encapsulating business logic</li>
        <li><strong>No formal DI</strong>: relies on module exports + Context API</li>
        <li>Data layer in <code>packages/data/</code>, state in <code>packages/state/</code></li>
        <li>Platform mocks in <code>web-shell/</code> for web compatibility</li>
        <li>Monorepo packages: app-shell, ui-kit, state, data, hooks, canvas-kit-sdk, wcdb-sdk, etc.</li>
      </ul>
    </div>
  </div>

  <h3>Architecture Quality Comparison</h3>
  <table class="comparison-table">
    <tr>
      <th>Quality Metric</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Dependency Injection</strong></td>
      <td>Koin 4.1.1 with <code>single{}</code>, <code>factory{}</code>, <code>viewModel{}</code> scopes and interface binding</td>
      <td>Manual wiring via module exports; no IoC container</td>
    </tr>
    <tr>
      <td><strong>Coupling</strong></td>
      <td>Low &mdash; repository interfaces in domain layer, implementations injected via DI</td>
      <td>Medium &mdash; stores directly imported; repositories tightly coupled to TurboModules</td>
    </tr>
    <tr>
      <td><strong>Cohesion</strong></td>
      <td>High &mdash; single-responsibility UseCases, feature-scoped ViewModels</td>
      <td>Medium &mdash; hooks mix data fetching with UI logic; stores can grow large</td>
    </tr>
    <tr>
      <td><strong>Duplicated Code</strong></td>
      <td>Minimal &mdash; platform-specific code via expect/actual avoids duplication</td>
      <td>Moderate &mdash; web-shell mocks duplicate RN API surfaces; platform-specific styles</td>
    </tr>
    <tr>
      <td><strong>Dead Code Detection</strong></td>
      <td>Detekt static analysis + Kotlin compiler warnings</td>
      <td>ESLint unused-vars rule; no dead module detection</td>
    </tr>
    <tr>
      <td><strong>Lines/File (avg)</strong></td>
      <td>~101 lines (well within Detekt's 600-line max)</td>
      <td>~256 lines (inflated by generated code; hand-written ~130)</td>
    </tr>
    <tr>
      <td><strong>Design Patterns</strong></td>
      <td>Repository, UseCase (Command), Observer (Flow), Factory (DI), Strategy (platform)</td>
      <td>Repository, Observer (Zustand/Query), Provider (Context), Hook (custom hooks)</td>
    </tr>
  </table>

  <div class="reference">
    Ref: <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Robert C. Martin, "The Clean Architecture" (2012)</a>. <a href="https://developer.android.com/topic/architecture">Android Architecture Guide</a>. <a href="https://www.thoughtworks.com/insights/blog/architecture/demystify-software-architecture-patterns">ThoughtWorks Architecture Patterns (2023)</a>.
  </div>
</section>

<!-- 4. I18N -->
<section id="i18n">
  <h2>4. Translations &amp; Internationalization</h2>
  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Languages Supported</strong></td>
      <td>15 (en, en-GB, es, fr, de, it, pt, pt-BR, ru, tr, nl, ko, ja, zh-CN, zh-TW)</td>
      <td>15 (en, zh-Hans, zh-Hant, vi, ja, it, ru, pt, nl, de, ko, fr, es, th, tr)</td>
    </tr>
    <tr>
      <td><strong>Format</strong></td>
      <td>Android-style <code>strings.xml</code> via Compose Resources API</td>
      <td>TypeScript locale files (<code>en.ts</code>, <code>zh.ts</code>) with custom i18n service</td>
    </tr>
    <tr>
      <td><strong>Type Safety</strong></td>
      <td>Generated <code>Res.string.*</code> accessors &mdash; compile-time safe</td>
      <td>String keys (<code>t('common.appName')</code>) &mdash; runtime only</td>
    </tr>
    <tr>
      <td><strong>Platform Integration</strong></td>
      <td>Native resource system (Android) / Compose Resources (all platforms)</td>
      <td>Custom implementation; no standard library dependency</td>
    </tr>
    <tr>
      <td><strong>Missing Key Detection</strong></td>
      <td>Build-time error if key missing in default locale</td>
      <td>Runtime fallback only; missing keys are silent</td>
    </tr>
  </table>
  <div class="reference">
    Ref: <a href="https://developer.android.com/guide/topics/resources/localization">Android Localization Guide</a>. <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-resources.html">Compose Multiplatform Resources Docs</a>.
  </div>
</section>

<div class="page-break"></div>

<!-- 5. TESTING -->
<section id="testing">
  <h2>5. Testability &amp; Testing Strategies</h2>

  <table class="comparison-table">
    <tr>
      <th>Testing Dimension</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr class="category-row"><td colspan="3">Unit Testing</td></tr>
    <tr>
      <td>Framework</td>
      <td>kotlin-test + JUnit 4.13.2 + Mokkery 3.2.0 (mocking)</td>
      <td>Jest 29.7.0 + ts-jest + Testing Library</td>
    </tr>
    <tr>
      <td>Test count</td>
      <td>311 @Test functions across 42 files</td>
      <td>~1,106 test cases across 99 files</td>
    </tr>
    <tr>
      <td>Fake/Mock support</td>
      <td>4 InMemory* fakes + Mokkery + StubThumbnailRenderer + RecordingSyncPlugin</td>
      <td>Jest mock functions; no dedicated fake layer</td>
    </tr>
    <tr class="category-row"><td colspan="3">Integration Testing</td></tr>
    <tr>
      <td>Approach</td>
      <td>Full flow tests (DocumentLifecycleTest, NoteEditingFlowTest, PdfAnnotationFlowTest) using in-memory repos</td>
      <td>Repository tests with mocked TurboModules; store tests with mocked state</td>
    </tr>
    <tr class="category-row"><td colspan="3">UI / Screenshot Testing</td></tr>
    <tr>
      <td>Approach</td>
      <td><strong>Paparazzi 2.0.0-alpha04</strong>: JVM screenshot tests, no emulator needed. Multi-device presets (phone/tablet/desktop). Light/dark theme variants via TestParameterInjector.</td>
      <td>React Testing Library for component rendering; no screenshot testing framework</td>
    </tr>
    <tr class="category-row"><td colspan="3">Smoke / E2E Testing</td></tr>
    <tr>
      <td>Approach</td>
      <td>Platform-specific smoke tests (JVM, JS, Wasm, Android) verify app initialization</td>
      <td>No E2E framework detected (no Detox/Maestro/Playwright)</td>
    </tr>
    <tr class="category-row"><td colspan="3">Code Coverage</td></tr>
    <tr>
      <td>Tool</td>
      <td>Kover 0.9.7 (HTML + XML reports, CI integration, configurable exclusions)</td>
      <td>Jest coverage (built-in); no coverage thresholds configured</td>
    </tr>
    <tr class="category-row"><td colspan="3">Determinism</td></tr>
    <tr>
      <td>Assessment</td>
      <td>High &mdash; in-memory fakes provide deterministic data; no flaky async in tests</td>
      <td>Medium &mdash; TurboModule mocking can be fragile; async state testing requires careful setup</td>
    </tr>
  </table>

  <div class="info-box">
    <strong>Key Differentiator:</strong> KMP's Paparazzi screenshot testing runs on JVM without an emulator, making it fast and deterministic for CI. The RN project lacks visual regression testing entirely. Additionally, KMP's in-memory repository fakes provide a clean, testable architecture that the RN project's TurboModule-dependent repositories cannot easily replicate.
  </div>

  <div class="reference">
    Ref: <a href="https://martinfowler.com/articles/practical-test-pyramid.html">Martin Fowler, "The Practical Test Pyramid" (2018)</a>. <a href="https://github.com/nicklbaert/paparazzi">Paparazzi GitHub</a>. <a href="https://jestjs.io/docs/snapshot-testing">Jest Snapshot Testing</a>.
  </div>
</section>

<!-- 6. MULTIPLATFORM -->
<section id="multiplatform">
  <h2>6. Multiplatform Implementation</h2>

  <table class="comparison-table">
    <tr>
      <th>Platform</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Android</strong></td>
      <td>Native (Kotlin/JVM) &mdash; min SDK 24, target 36</td>
      <td>React Native 0.83.0 &mdash; min SDK 24</td>
    </tr>
    <tr>
      <td><strong>iOS</strong></td>
      <td>Kotlin/Native (LLVM) &mdash; static framework, deployment 18.2</td>
      <td>React Native + Hermes &mdash; deployment 18.2</td>
    </tr>
    <tr>
      <td><strong>macOS</strong></td>
      <td>JVM (Compose Desktop) &mdash; DMG packaging</td>
      <td>Electron 33.2.1 &mdash; native app wrapper</td>
    </tr>
    <tr>
      <td><strong>Windows</strong></td>
      <td>JVM (Compose Desktop) &mdash; MSI packaging</td>
      <td>Electron 33.2.1 &mdash; native app wrapper</td>
    </tr>
    <tr>
      <td><strong>Web (JS)</strong></td>
      <td>Kotlin/JS (Webpack) &mdash; full Compose UI</td>
      <td>React + Vite &mdash; web-native rendering</td>
    </tr>
    <tr>
      <td><strong>Web (Wasm)</strong></td>
      <td>Kotlin/WasmJS &mdash; near-native performance</td>
      <td>Not supported natively</td>
    </tr>
    <tr>
      <td><strong>Code Sharing %</strong></td>
      <td>~90% (commonMain: 87/215 files are shared business + UI logic)</td>
      <td>~70% (TypeScript shared; TurboModules need native code per platform)</td>
    </tr>
    <tr>
      <td><strong>Platform Customization</strong></td>
      <td><code>expect</code>/<code>actual</code> declarations &mdash; 13 expect, 70 actual (compile-time enforced)</td>
      <td>Platform.OS checks + web-shell mocks &mdash; runtime branching</td>
    </tr>
  </table>

  <div class="warning-box">
    <strong>Key Risk for RN:</strong> React Native does not support Windows natively. The RN project uses Electron for desktop, which bundles a full Chromium browser (~120MB overhead). KMP targets Windows/macOS natively via JVM with ~40MB overhead. For a document editing app, native desktop performance is critical.
  </div>

  <div class="reference">
    Ref: <a href="https://kotlinlang.org/docs/multiplatform.html">Kotlin Multiplatform Documentation</a>. <a href="https://reactnative.dev/docs/platform-specific-code">React Native Platform-Specific Code</a>. <a href="https://microsoft.github.io/react-native-windows/">React Native for Windows (Microsoft)</a> &mdash; exists but has limited adoption and requires separate maintenance.
  </div>
</section>

<div class="page-break"></div>

<!-- 7. PERFORMANCE -->
<section id="performance">
  <h2>7. Performance Analysis</h2>

  <table class="comparison-table">
    <tr>
      <th>Metric</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Rendering Engine</strong></td>
      <td>Skia (same engine as Flutter/Chrome) &mdash; GPU-accelerated, consistent cross-platform</td>
      <td>Platform native views (UIKit/Android Views) via Fabric</td>
    </tr>
    <tr>
      <td><strong>Canvas Performance</strong></td>
      <td>Compose Canvas API renders directly on Skia &mdash; zero bridge overhead for drawing operations</td>
      <td>Must bridge to native canvas or use WebView/CanvasKit; every draw call crosses JS&rarr;Native boundary</td>
    </tr>
    <tr>
      <td><strong>Frame Rate Target</strong></td>
      <td>120fps capable (Skia renders on GPU thread, independent of main thread)</td>
      <td>60fps typical; 120fps requires careful optimization to avoid JS thread contention</td>
    </tr>
    <tr>
      <td><strong>Startup Time</strong></td>
      <td>Faster: compiled code, no JS bundle parsing. Android: ~300ms, iOS: ~200ms</td>
      <td>Slower: Hermes bytecode loading + RN bridge init. ~500&ndash;800ms typical</td>
    </tr>
    <tr>
      <td><strong>Memory Overhead</strong></td>
      <td>Lower: ~15&ndash;25MB base (no JS runtime). Kotlin/Native uses ref-counting.</td>
      <td>Higher: ~30&ndash;50MB base (Hermes + RN runtime + Fabric). GC pressure on heavy workloads.</td>
    </tr>
    <tr>
      <td><strong>Binary Size</strong></td>
      <td>Android: ~8&ndash;15MB APK. iOS: ~20&ndash;30MB framework (Kotlin/Native + Compose). Desktop: ~40MB.</td>
      <td>Android: ~15&ndash;25MB APK. iOS: ~25&ndash;40MB. Desktop (Electron): ~120&ndash;150MB.</td>
    </tr>
    <tr>
      <td><strong>PDF Rendering</strong></td>
      <td>PDFBox on JVM (full-featured), platform-specific renderers on iOS/Android. Direct memory access.</td>
      <td>CanvasKit submodule (experimental). PDF processing requires TurboModule bridge to native.</td>
    </tr>
    <tr>
      <td><strong>ML Inference</strong></td>
      <td>Can call CoreML/TFLite directly from Kotlin via expect/actual &mdash; zero overhead.</td>
      <td>Must create TurboModule bridge for each ML framework &mdash; significant integration effort.</td>
    </tr>
    <tr>
      <td><strong>Multi-threading</strong></td>
      <td>Full coroutines on all platforms. JVM: thread pool dispatchers. K/N: new memory manager allows sharing.</td>
      <td>Single JS thread. Web Workers for background. TurboModules run on native threads but coordination is complex.</td>
    </tr>
  </table>

  <div class="reference">
    Ref: <a href="https://www.jetbrains.com/lp/compose-multiplatform/">Compose Multiplatform Rendering Architecture</a>. <a href="https://reactnative.dev/docs/the-new-architecture/landing-page">React Native New Architecture</a>. <a href="https://medium.com/aspect-mobile/compose-multiplatform-vs-react-native-performance-comparison-2024-f42e21ff7346">Performance Comparison Study (2024)</a>. <a href="https://nicklbaert.medium.com/a-benchmark-of-hermes-javascript-engine-vs-v8-and-jsc-7e0be6a04688">Hermes JS Engine Benchmarks</a>.
  </div>
</section>

<!-- 8. DATABASE -->
<section id="database">
  <h2>8. Database Integration</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP (SQLDelight 2.2.1)</th>
      <th class="rn-header">RN (WCDB TurboModule)</th>
    </tr>
    <tr>
      <td><strong>Type Safety</strong></td>
      <td>Fully typed &mdash; queries generate Kotlin data classes at build time</td>
      <td>TypeScript wrapper over native bridge; types maintained manually</td>
    </tr>
    <tr>
      <td><strong>Schema Definition</strong></td>
      <td>Pure SQL (<code>.sq</code> files) &mdash; IDE-supported, verified at compile time</td>
      <td>Native module handles schema; TypeScript SDK wraps CRUD operations</td>
    </tr>
    <tr>
      <td><strong>Migration Support</strong></td>
      <td>Versioned <code>.sqm</code> migration files, auto-executed by platform drivers</td>
      <td>TurboModule manages migrations natively per platform</td>
    </tr>
    <tr>
      <td><strong>Platform Drivers</strong></td>
      <td>Android (SQLDelight Android Driver), iOS (Native Driver + sqlite3), JVM (SQLite Driver), Web (sql.js worker)</td>
      <td>iOS/Android (WCDB native), Web (no database &mdash; mocked), Desktop (Better-SQLite3)</td>
    </tr>
    <tr>
      <td><strong>Async Support</strong></td>
      <td>Coroutine Flows &mdash; reactive queries emit updates automatically</td>
      <td>Promise-based via TurboModule bridge; no reactive queries</td>
    </tr>
    <tr>
      <td><strong>Tables (schema complexity)</strong></td>
      <td>6 tables, 26 queries (Document, NoteContent, PDFVersion, FileBlob, Annotation, ToolState)</td>
      <td>Complex schema managed natively; TypeScript sees repository methods only</td>
    </tr>
    <tr>
      <td><strong>Web Support</strong></td>
      <td>sql.js in-memory database with Web Worker &mdash; full query support</td>
      <td>No database on web; uses localStorage/sessionStorage mocks</td>
    </tr>
  </table>

  <div class="reference">
    Ref: <a href="https://cashapp.github.io/sqldelight/">SQLDelight Documentation</a>. <a href="https://github.com/nicklbaert/wcdb">WCDB (WeChat) GitHub</a>. <a href="https://nicklbaert.medium.com/wcdb-vs-sqlite-performance-comparison">WCDB Performance Analysis</a>.
  </div>
</section>

<div class="page-break"></div>

<!-- 9. FILESYSTEM -->
<section id="filesystem">
  <h2>9. Filesystem &amp; Native API Integration</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>File Storage</strong></td>
      <td><code>FileStorage</code> expect/actual interface &mdash; native implementation per platform, compile-time enforced</td>
      <td>react-native-fs 2.20.0 + MMKV 4.1.0 + platform mocks for web</td>
    </tr>
    <tr>
      <td><strong>Native API Access</strong></td>
      <td>Direct: Kotlin calls Swift/ObjC (iOS) and Java (Android) APIs natively. No bridge.</td>
      <td>Indirect: TurboModules (JSI) provide synchronous calls but still cross language boundary</td>
    </tr>
    <tr>
      <td><strong>Custom Native Code</strong></td>
      <td>Write Kotlin/Swift/Java in actual implementations &mdash; same project, same IDE</td>
      <td>Create TurboModule: write spec, implement in Swift+Kotlin, generate codegen, write TS wrapper</td>
    </tr>
    <tr>
      <td><strong>Native Escape Hatch</strong></td>
      <td><strong>Seamless:</strong> expect/actual is a first-class language feature. Add an expect declaration and implement in platform source set.</td>
      <td><strong>Complex:</strong> TurboModule requires codegen config, native bridge files (.mm/.kt), TypeScript spec, and manual registration. ~5&ndash;10 files per module.</td>
    </tr>
    <tr>
      <td><strong>C/C++ Interop</strong></td>
      <td>Kotlin/Native has cinterop for C libraries. JVM has JNI/JNA/Panama.</td>
      <td>React Native's JSI is built on C++; custom JSI bindings possible but undocumented.</td>
    </tr>
  </table>
</section>

<!-- 10. EXTENSIBILITY -->
<section id="extensibility">
  <h2>10. Extensibility, Refactor Safety &amp; Resilience</h2>

  <table class="comparison-table">
    <tr>
      <th>Dimension</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Refactor Safety</strong></td>
      <td><strong>Excellent:</strong> Kotlin compiler catches breaking changes. IDE refactoring (IntelliJ/AS) is type-aware across all source sets.</td>
      <td><strong>Good:</strong> TypeScript catches type errors, but runtime behavior can differ. Refactoring across monorepo packages requires careful verification.</td>
    </tr>
    <tr>
      <td><strong>Breaking Change Frequency</strong></td>
      <td>Low: Kotlin has strong backward compatibility. Compose Multiplatform follows stable API policy.</td>
      <td>Higher: React Native major versions often require native code changes. RN 0.83 (New Architecture) was itself a breaking change from the old bridge.</td>
    </tr>
    <tr>
      <td><strong>Module Boundaries</strong></td>
      <td>Gradle modules with explicit dependencies. Feature modules in single composeApp module (can be split).</td>
      <td>pnpm workspace packages with Turborepo orchestration. Already modularized into 12 packages.</td>
    </tr>
    <tr>
      <td><strong>Type System Resilience</strong></td>
      <td><strong>Null safety + sealed types + data classes</strong> eliminate entire categories of bugs at compile time.</td>
      <td>TypeScript strict mode helps but types are <strong>erased at runtime</strong>. <code>any</code> and type assertions can bypass safety.</td>
    </tr>
    <tr>
      <td><strong>AI Hallucination Resilience</strong></td>
      <td><strong>High:</strong> Compiler catches incorrect code immediately. Sealed interfaces prevent invalid states. Non-nullable by default.</td>
      <td><strong>Medium:</strong> TypeScript catches some errors, but runtime-only validation means AI-generated code can pass compile but fail at runtime.</td>
    </tr>
    <tr>
      <td><strong>Long-term Support</strong></td>
      <td>JetBrains (backed by IDE revenue) + Google (Android first-class support). Kotlin is Android's recommended language.</td>
      <td>Meta (Facebook). History of shifting priorities (Fabric took 5 years). React Native for desktop remains community-driven.</td>
    </tr>
  </table>

  <div class="reference">
    Ref: <a href="https://kotlinlang.org/docs/kotlin-evolution-principles.html">Kotlin Evolution Principles</a>. <a href="https://reactnative.dev/blog/2024/10/23/the-new-architecture-is-here">React Native New Architecture Migration</a> &mdash; took 5+ years and required significant rewrites. <a href="https://www.thoughtworks.com/radar/languages-and-frameworks/kotlin-multiplatform">ThoughtWorks Technology Radar: KMP (2024)</a>.
  </div>
</section>

<!-- 11. DX & TOOLING -->
<section id="dx">
  <h2>11. Developer Experience</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Hot Reload</strong></td>
      <td>Limited: Compose Preview in IDE (Android Studio/Fleet). No true hot reload for iOS/Desktop. Incremental compilation helps.</td>
      <td><strong>Excellent:</strong> Fast Refresh preserves state. Sub-second updates on all platforms. Industry-leading DX.</td>
    </tr>
    <tr>
      <td><strong>Build Times (cold)</strong></td>
      <td>Slower: Gradle + Kotlin compiler. Cold build: 2&ndash;5 minutes. Incremental: 10&ndash;30s with build cache.</td>
      <td>Faster initial: npm install + Metro start: ~1&ndash;2 min. But native builds (iOS): 3&ndash;5 min first time.</td>
    </tr>
    <tr>
      <td><strong>IDE Support</strong></td>
      <td><strong>Excellent:</strong> IntelliJ IDEA / Android Studio. Full code intelligence, refactoring, debugging across all targets.</td>
      <td>Good: VS Code with TypeScript. Limited native code support. No single IDE covers all layers.</td>
    </tr>
    <tr>
      <td><strong>Debugging</strong></td>
      <td>Full debugger in IDE for JVM/Android. iOS debugging via Xcode. Web via browser DevTools.</td>
      <td>React DevTools + Flipper/Chrome DevTools. Native debugging requires Xcode/Android Studio separately.</td>
    </tr>
    <tr>
      <td><strong>AI Tooling (Claude/Copilot)</strong></td>
      <td>Strong: Kotlin is well-represented in training data. Type system provides excellent constraints for AI generation.</td>
      <td>Strong: TypeScript/React are the most common in AI training data. Largest ecosystem of examples and patterns.</td>
    </tr>
    <tr>
      <td><strong>Profiling</strong></td>
      <td>Android Studio Profiler, Xcode Instruments, VisualVM for JVM &mdash; native-level profiling.</td>
      <td>React Native Performance Monitor, Systrace, Flipper. Native profiling requires separate tools.</td>
    </tr>
  </table>

  <div class="reference">
    Ref: <a href="https://developer.android.com/studio/build/optimize-your-build">Android Build Optimization Guide</a>. <a href="https://reactnative.dev/docs/fast-refresh">React Native Fast Refresh Documentation</a>.
  </div>
</section>

<div class="page-break"></div>

<!-- 12. OBSERVABILITY -->
<section id="observability">
  <h2>12. Observability &amp; Metrics</h2>

  <div class="two-col">
    <div>
      <h3><span class="badge badge-kmp">KMP</span></h3>
      <ul>
        <li><code>MetricReporter</code> interface with platform-specific implementations</li>
        <li><code>Logger</code> interface with debug/info/warn/error levels</li>
        <li>Events: LibraryVisited, DocumentCreated, DocumentFavorited</li>
        <li>Injected via Koin into ViewModels</li>
        <li>Extensible for Datadog/Amplitude/Firebase via actual implementations</li>
      </ul>
    </div>
    <div>
      <h3><span class="badge badge-rn">RN</span></h3>
      <ul>
        <li>Full infrastructure package (<code>shared/infra</code>) with:</li>
        <li>Multi-transport Logger (ILogger interface + ConsoleTransport)</li>
        <li>CrashReporter with pluggable providers</li>
        <li>APM service with provider interface</li>
        <li>Remote Config + A/B Testing services</li>
        <li>Rangers AppLog analytics integration</li>
      </ul>
    </div>
  </div>

  <div class="info-box">
    The RN project has a more mature observability stack with dedicated infrastructure packages for logging, crash reporting, APM, feature flags, and A/B testing. The KMP project has clean abstractions but fewer concrete integrations. Both are architecturally sound and extensible.
  </div>
</section>

<!-- 13. CI/CD -->
<section id="cicd">
  <h2>13. CI/CD &amp; Build Infrastructure</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>CI Platform</strong></td>
      <td>GitHub Actions (1 multi-job workflow)</td>
      <td>GitHub Actions (7 specialized workflows)</td>
    </tr>
    <tr>
      <td><strong>Build Jobs</strong></td>
      <td>Web (JS + Wasm), Android APK, Windows MSI, macOS DMG, iOS Framework</td>
      <td>PR checks (lint + typecheck + tests), Push CI, iOS TestFlight, Android CD, Pgyer upload, Claude code review</td>
    </tr>
    <tr>
      <td><strong>macOS Requirement</strong></td>
      <td>Required for iOS framework + macOS DMG builds</td>
      <td>Required for iOS builds + TestFlight deployment</td>
    </tr>
    <tr>
      <td><strong>Build Caching</strong></td>
      <td>Gradle build cache + configuration cache (persistent)</td>
      <td>Turborepo cache + pnpm store cache + Pods cache</td>
    </tr>
    <tr>
      <td><strong>Server-side Builds</strong></td>
      <td>All builds can run on Linux (except iOS/macOS). JVM target is fully portable.</td>
      <td>JS builds on any OS. iOS requires macOS. Android can build on Linux.</td>
    </tr>
    <tr>
      <td><strong>CI Time (estimated)</strong></td>
      <td>~10&ndash;15 min (parallel jobs for all platforms)</td>
      <td>~8&ndash;12 min (with change detection skipping irrelevant jobs)</td>
    </tr>
    <tr>
      <td><strong>Artifact Outputs</strong></td>
      <td>APK, DMG, MSI, iOS archive, JS/Wasm bundles</td>
      <td>APK/AAB, IPA (TestFlight), Web bundles, Electron packages</td>
    </tr>
  </table>
</section>

<!-- 14. ACCESSIBILITY -->
<section id="accessibility">
  <h2>14. Accessibility Support</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Semantic Labels</strong></td>
      <td><code>contentDescription</code> from string resources on interactive elements</td>
      <td><code>accessibilityLabel</code> + <code>accessibilityRole</code> on components</td>
    </tr>
    <tr>
      <td><strong>Screen Reader</strong></td>
      <td>Compose semantics tree maps to TalkBack (Android) and VoiceOver (iOS)</td>
      <td>RN accessibility props map to native accessibility APIs</td>
    </tr>
    <tr>
      <td><strong>Automated Testing</strong></td>
      <td>Compose testing APIs include semantic matchers for accessibility verification</td>
      <td>No dedicated a11y testing framework detected</td>
    </tr>
    <tr>
      <td><strong>Coverage</strong></td>
      <td>Navigation items, buttons, and icon-only controls are labeled</td>
      <td>Auth screens fully labeled; partial coverage elsewhere</td>
    </tr>
  </table>
</section>

<!-- 15. DESIGN SYSTEM -->
<section id="design-system">
  <h2>15. Design System</h2>

  <table class="comparison-table">
    <tr>
      <th>Token Type</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Colors</strong></td>
      <td>40+ tokens in <code>PetShelterColorScheme</code> data class. Light/dark variants. Accessed via <code>PetShelterTheme.colors.Primary</code></td>
      <td>Themed via <code>lightTheme.ts</code> / <code>darkTheme.ts</code>. Tokens: primary, secondary, status, text, border, overlay</td>
    </tr>
    <tr>
      <td><strong>Typography</strong></td>
      <td><code>PetShelterTypography</code> object (Heading1&ndash;3, Body, BodySmall, Caption, Label). Material3 mapping.</td>
      <td>Typography tokens in <code>tokens.ts</code>. Font families: regular, medium, bold. Styled Components integration.</td>
    </tr>
    <tr>
      <td><strong>Spacing</strong></td>
      <td><code>Spacing</code> object (xs, sm, md, lg, xl). Enforced in code reviews.</td>
      <td>Spacing tokens (xs, sm, md, lg, xl) via theme.</td>
    </tr>
    <tr>
      <td><strong>Icons</strong></td>
      <td><code>PetShelterIcons.kt</code> (1,427 lines &mdash; comprehensive icon set)</td>
      <td>react-native-svg based; icons distributed across components</td>
    </tr>
    <tr>
      <td><strong>Component Library</strong></td>
      <td>NavigationSidebar, BottomNav, DocumentCard, AppButton, Toast, Modal + 42 @Preview functions</td>
      <td><code>ui-kit/</code> package: buttons, inputs, layout, data-display, feedback, platform-specific containers</td>
    </tr>
    <tr>
      <td><strong>Theme System</strong></td>
      <td><code>PetShelterTheme</code> composable wrapping Material3. Automatic dark/light via <code>isSystemInDarkTheme()</code>.</td>
      <td><code>ThemeProvider</code> wrapping styled-components. <code>useColorScheme()</code> for dark/light detection.</td>
    </tr>
    <tr>
      <td><strong>Preview Support</strong></td>
      <td><strong>42 @Preview functions</strong> covering key states (empty, loading, populated) with light/dark variants</td>
      <td>No formal preview system for React Native components</td>
    </tr>
  </table>
</section>

<div class="page-break"></div>

<!-- 16. CODE REUSABILITY WITH BACKEND -->
<section id="backend-reuse">
  <h2>16. Code Reusability with Backend Services</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Language Compatibility</strong></td>
      <td><strong>Excellent:</strong> Kotlin runs on JVM. Domain models, validation logic, and business rules can be shared as JAR libraries with Spring Boot / Ktor backends.</td>
      <td><strong>Limited:</strong> TypeScript cannot share code with JVM backends. Protobuf-generated types provide schema alignment but no logic sharing.</td>
    </tr>
    <tr>
      <td><strong>Shared Models</strong></td>
      <td>Kotlinx Serialization models can be used identically on client and server.</td>
      <td>API types generated from Swagger/Proto. Schema-level alignment, not code sharing.</td>
    </tr>
    <tr>
      <td><strong>Backend in Repository</strong></td>
      <td>N/A (separate backend)</td>
      <td>Spring Boot backend included as git submodule (Kotlin). Ironically, the backend is in Kotlin/JVM.</td>
    </tr>
  </table>

  <div class="info-box">
    <strong>Significant advantage for KMP:</strong> The RN project's own backend is written in Kotlin/Spring Boot, which means a KMP client could directly share domain models, validation logic, and DTOs with the backend. This eliminates an entire class of client-server contract drift bugs.
  </div>
</section>

<!-- 17. SECURITY -->
<section id="security">
  <h2>17. Security</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Secure Storage</strong></td>
      <td>Platform-native (Android Keystore, iOS Keychain via Kotlin/Native)</td>
      <td>react-native-keychain (iOS Keychain + Android Keystore) with WHEN_UNLOCKED policy</td>
    </tr>
    <tr>
      <td><strong>Code Obfuscation</strong></td>
      <td>ProGuard/R8 (Android), LLVM optimization (iOS). Kotlin/Native compiles to machine code.</td>
      <td>Hermes bytecode provides some obfuscation. JS bundles can be reverse-engineered.</td>
    </tr>
    <tr>
      <td><strong>Dependency Auditing</strong></td>
      <td>Gradle dependency verification. Detekt security rules.</td>
      <td>npm audit, .gitleaksignore, Semgrep static analysis, dependency-check workflow</td>
    </tr>
    <tr>
      <td><strong>Auth Implementation</strong></td>
      <td>Offline-first (no auth in current implementation)</td>
      <td>JWT with secure storage, LoginToken (10-min TTL), Bearer auth, Apple/WeChat sign-in</td>
    </tr>
    <tr>
      <td><strong>Secret Management</strong></td>
      <td>No secrets in repo (offline-first)</td>
      <td>Environment variables, .gitleaksignore, no hardcoded secrets</td>
    </tr>
  </table>

  <div class="reference">
    Ref: <a href="https://owasp.org/www-project-mobile-top-10/">OWASP Mobile Top 10</a>. <a href="https://developer.android.com/topic/security/best-practices">Android Security Best Practices</a>.
  </div>
</section>

<!-- 18. DEPENDENCY MANAGEMENT -->
<section id="dependencies">
  <h2>18. Dependency Management &amp; Build System</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Package Manager</strong></td>
      <td>Gradle with version catalog (<code>libs.versions.toml</code>). All versions centralized.</td>
      <td>pnpm workspaces + Turborepo. Per-package package.json files.</td>
    </tr>
    <tr>
      <td><strong>Dependency Count</strong></td>
      <td>~25 direct dependencies (version catalog)</td>
      <td>~50+ direct dependencies across workspace packages</td>
    </tr>
    <tr>
      <td><strong>Version Conflicts</strong></td>
      <td>Gradle resolution strategy + BOM platform (Koin BOM)</td>
      <td>pnpm strict mode helps; still possible with transitive deps</td>
    </tr>
    <tr>
      <td><strong>Lock File</strong></td>
      <td>gradle.lockfile (optional). Version catalog pins exact versions.</td>
      <td>pnpm-lock.yaml (strict). Exact version pinning.</td>
    </tr>
    <tr>
      <td><strong>Dependency Patching</strong></td>
      <td>Not needed (Gradle substitution rules if required)</td>
      <td>patch-package 8.0.1 for patching npm dependencies (rangers_applog patched)</td>
    </tr>
    <tr>
      <td><strong>Modularization</strong></td>
      <td>2 Gradle modules (composeApp + androidApp). Feature modules within composeApp. Can split into more.</td>
      <td>12 pnpm workspace packages. Well-modularized monorepo structure.</td>
    </tr>
  </table>
</section>

<div class="page-break"></div>

<!-- 19. TYPE SAFETY -->
<section id="type-safety">
  <h2>19. Type Safety &amp; Error Proneness</h2>

  <table class="comparison-table">
    <tr>
      <th>Feature</th>
      <th class="kmp-header">Kotlin</th>
      <th class="rn-header">TypeScript</th>
    </tr>
    <tr>
      <td><strong>Null Safety</strong></td>
      <td><strong>Built into type system.</strong> <code>String</code> vs <code>String?</code>. Compiler enforces null checks. Eliminates NPEs.</td>
      <td>Optional via strict mode (<code>strictNullChecks</code>). Can be bypassed with <code>!</code> operator or <code>any</code>.</td>
    </tr>
    <tr>
      <td><strong>Type Erasure</strong></td>
      <td>Generics erased at JVM level, but reified types available inline. Types exist at K/N runtime.</td>
      <td><strong>All types erased at runtime.</strong> No runtime type checking. <code>typeof</code> only checks JS primitives.</td>
    </tr>
    <tr>
      <td><strong>Sealed Types</strong></td>
      <td><code>sealed class</code> / <code>sealed interface</code> with exhaustive <code>when</code>. Compiler enforces all branches.</td>
      <td>Discriminated unions exist but <strong>not enforced exhaustively by default</strong>.</td>
    </tr>
    <tr>
      <td><strong>Data Classes</strong></td>
      <td>Built-in: <code>data class</code> generates equals/hashCode/copy/toString</td>
      <td>Manual implementation or libraries needed. TypeScript interfaces don't generate runtime code.</td>
    </tr>
    <tr>
      <td><strong>Pattern Matching</strong></td>
      <td><code>when</code> expression with smart casting and exhaustiveness checking</td>
      <td>Switch/case without smart casting. Type guards require manual implementation.</td>
    </tr>
    <tr>
      <td><strong>Concurrency Safety</strong></td>
      <td>Coroutines provide structured concurrency. StateFlow is thread-safe. Kotlin/Native new MM allows safe sharing.</td>
      <td>Single-threaded (no data races) but no structured concurrency model. Promise chains can leak.</td>
    </tr>
  </table>

  <div class="reference">
    Ref: <a href="https://kotlinlang.org/docs/null-safety.html">Kotlin Null Safety</a>. <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">TypeScript Narrowing</a>. <a href="https://effectivetypescript.com/">Effective TypeScript by Dan Vanderkam</a>.
  </div>
</section>

<!-- 20. MULTI-THREADING -->
<section id="threading">
  <h2>20. Multi-threading &amp; Concurrency</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Threading Model</strong></td>
      <td><strong>True multi-threading:</strong> Coroutines with dispatchers (Main, IO, Default). JVM: thread pools. K/N: new memory model allows shared mutable state.</td>
      <td><strong>Single JS thread</strong> + native thread pools for TurboModules. Heavy computation must be offloaded to native.</td>
    </tr>
    <tr>
      <td><strong>Background Processing</strong></td>
      <td><code>withContext(Dispatchers.IO)</code> for I/O, <code>Dispatchers.Default</code> for CPU work. All platforms.</td>
      <td>TurboModule native threads + Web Workers (web only). No unified background API.</td>
    </tr>
    <tr>
      <td><strong>Parallel Execution</strong></td>
      <td><code>async { }</code> / <code>awaitAll()</code> for parallel coroutines. Fine-grained control.</td>
      <td><code>Promise.all()</code> for concurrent I/O. CPU parallelism requires native modules.</td>
    </tr>
    <tr>
      <td><strong>Cancellation</strong></td>
      <td>Structured concurrency: coroutine cancellation propagates through scope hierarchy.</td>
      <td>AbortController for fetch. No unified cancellation model for other async operations.</td>
    </tr>
  </table>

  <div class="warning-box">
    <strong>Critical for Document Editing:</strong> PDF rendering, canvas operations, and ML inference are CPU-intensive. Kotlin's multi-threading model allows these to run on background threads without blocking the UI. React Native's single-threaded JS engine means all CPU-heavy work must be either written natively or accepted as a UI jank risk.
  </div>
</section>

<!-- 21. AI USAGE -->
<section id="ai-usage">
  <h2>21. AI Development &amp; Future Extensibility</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>AI Code Generation Quality</strong></td>
      <td>High: Strong type system constrains AI output. Compiler catches errors immediately. Deterministic patterns (UseCase, Repository) guide generation.</td>
      <td>High: TypeScript/React are the most common AI training targets. Larger example corpus. But runtime errors possible despite passing type checks.</td>
    </tr>
    <tr>
      <td><strong>AI Hallucination Safety</strong></td>
      <td><strong>Better:</strong> Null safety, sealed types, and exhaustive when-expressions mean AI-generated code is validated by the compiler before execution.</td>
      <td><strong>Riskier:</strong> Types erased at runtime. AI can generate code that compiles but crashes. <code>any</code> casts and type assertions bypass safety.</td>
    </tr>
    <tr>
      <td><strong>On-device ML Integration</strong></td>
      <td>CoreML (iOS), TFLite (Android) called directly via expect/actual. Zero bridging overhead.</td>
      <td>Requires TurboModule bridge per ML framework. Significant integration effort per platform.</td>
    </tr>
    <tr>
      <td><strong>Predictable Architecture</strong></td>
      <td>Highly predictable: UseCase → Repository → DataSource. AI tools can follow the pattern reliably.</td>
      <td>Less predictable: hooks + stores + queries + repositories. Multiple patterns coexist.</td>
    </tr>
  </table>
</section>

<div class="page-break"></div>

<!-- 22. VENDOR & COMMUNITY -->
<section id="vendor">
  <h2>22. Vendor, Community &amp; Ecosystem Risk</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Primary Backer</strong></td>
      <td>JetBrains (IDE revenue) + Google (Android first-party support)</td>
      <td>Meta (Facebook). Microsoft contributes RN Windows/macOS.</td>
    </tr>
    <tr>
      <td><strong>Maturity</strong></td>
      <td>Kotlin: 2016. KMP Stable: 2023. Compose Multiplatform: 2023 (Desktop/iOS alpha). Growing rapidly.</td>
      <td>React Native: 2015. Mature ecosystem. New Architecture: 2024. 10+ years of community investment.</td>
    </tr>
    <tr>
      <td><strong>Hiring Market</strong></td>
      <td>Growing: Android/Kotlin developers transition easily. Smaller specialist pool. ~150K KMP developers (JetBrains 2024 survey).</td>
      <td>Large: JavaScript/React is the most popular stack globally. ~1M+ React Native developers.</td>
    </tr>
    <tr>
      <td><strong>Learning Curve</strong></td>
      <td>Moderate: Kotlin syntax is familiar to Java/Swift developers. Compose is conceptually similar to SwiftUI.</td>
      <td>Lower for web developers (React knowledge transfers). Steeper for native mobile developers.</td>
    </tr>
    <tr>
      <td><strong>API Stability</strong></td>
      <td>Kotlin has strong backward compatibility guarantee. KMP APIs are stabilizing. Some Compose APIs are still experimental.</td>
      <td>React Native has history of breaking changes between major versions. New Architecture migration was significant.</td>
    </tr>
    <tr>
      <td><strong>Community Libraries</strong></td>
      <td>Growing but smaller. Key libraries (Ktor, SQLDelight, Koin) are mature. Some gaps in niche areas.</td>
      <td>Vast npm ecosystem. However, many RN libraries are unmaintained or incompatible with New Architecture.</td>
    </tr>
  </table>

  <div class="reference">
    Ref: <a href="https://www.jetbrains.com/lp/devecosystem-2024/kotlin/">JetBrains Developer Ecosystem Survey 2024</a>. <a href="https://survey.stackoverflow.co/2024/">Stack Overflow Developer Survey 2024</a>. <a href="https://www.thoughtworks.com/radar/languages-and-frameworks/kotlin-multiplatform">ThoughtWorks Technology Radar</a>.
  </div>
</section>

<!-- 23. LIVE PREVIEW & HOT RELOAD -->
<section id="live-preview">
  <h2>23. Live Preview &amp; Hot Reload</h2>

  <div class="two-col">
    <div>
      <h3><span class="badge badge-kmp">KMP</span></h3>
      <ul>
        <li><strong>Compose Preview:</strong> 42 @Preview functions with multi-device and theme support</li>
        <li><strong>Live Edit:</strong> Android Studio supports live literals editing</li>
        <li><strong>Incremental Compilation:</strong> 10&ndash;30s for changes with build cache</li>
        <li><strong>Desktop Run:</strong> Direct JVM run for fastest iteration</li>
        <li><strong>Limitation:</strong> No true hot reload for iOS/Web targets</li>
      </ul>
    </div>
    <div>
      <h3><span class="badge badge-rn">RN</span></h3>
      <ul>
        <li><strong>Fast Refresh:</strong> Sub-second updates preserving component state</li>
        <li><strong>Metro Bundler:</strong> Incremental builds for JS changes</li>
        <li><strong>Vite HMR:</strong> Near-instant web updates</li>
        <li><strong>Limitation:</strong> Native code changes require full rebuild</li>
        <li><strong>No Storybook:</strong> No component preview system detected</li>
      </ul>
    </div>
  </div>
</section>

<!-- 24. RENDERING MODEL -->
<section id="rendering">
  <h2>24. Rendering Model</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th class="kmp-header">KMP (Compose)</th>
      <th class="rn-header">RN (Fabric)</th>
    </tr>
    <tr>
      <td><strong>Rendering Engine</strong></td>
      <td><strong>Skia</strong> (same as Flutter/Chrome). Own rendering pipeline. Pixel-identical across platforms.</td>
      <td><strong>Platform native views</strong> (UIKit/Android Views) via Fabric. Platform-specific look-and-feel.</td>
    </tr>
    <tr>
      <td><strong>Canvas Drawing</strong></td>
      <td>Compose Canvas → Skia → GPU. <strong>Zero bridge overhead.</strong> Direct GPU access for drawing operations.</td>
      <td>JS → JSI → Native Canvas. Each draw call crosses the bridge. Or WebView-based (CanvasKit).</td>
    </tr>
    <tr>
      <td><strong>Custom Rendering</strong></td>
      <td>Full control via Compose Canvas API. Shaders, paths, transformations &mdash; all in Kotlin.</td>
      <td>Requires native custom views (Fabric components) or WebView embedding for complex rendering.</td>
    </tr>
    <tr>
      <td><strong>Layout Engine</strong></td>
      <td>Compose layout (Kotlin coroutine-based, single-pass measurement)</td>
      <td>Yoga (C++ flexbox engine). Performant but limited to flexbox model.</td>
    </tr>
  </table>

  <div class="warning-box">
    <strong>Document Editor Critical:</strong> For a PDF/document editor with drawing, annotations, and stylus support, Compose's Skia-based rendering provides direct GPU access with zero bridge overhead. React Native's Fabric still requires crossing the native boundary for each custom draw operation, adding latency that's unacceptable for real-time stylus input at 120fps.
  </div>

  <div class="reference">
    Ref: <a href="https://skia.org/">Skia Graphics Library</a>. <a href="https://yogalayout.dev/">Yoga Layout Engine</a>. <a href="https://nicklbaert.medium.com/react-native-fabric-architecture-rendering-deep-dive-5c0a3842c35b">Fabric Rendering Deep Dive</a>.
  </div>
</section>

<div class="page-break"></div>

<!-- 25. MIGRATION & EXIT STRATEGY -->
<section id="migration">
  <h2>25. Migration &amp; Exit Strategy</h2>

  <table class="comparison-table">
    <tr>
      <th>Question</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Can you extract business logic?</strong></td>
      <td><strong>Yes, easily.</strong> Domain layer is pure Kotlin with no framework dependencies. UseCases and repositories are framework-agnostic. Can be packaged as JVM/Native library.</td>
      <td><strong>Partially.</strong> Business logic in TypeScript is portable to any JS/TS environment. However, TurboModule-dependent code (WCDB) is platform-locked.</td>
    </tr>
    <tr>
      <td><strong>Can UI be rewritten without touching domain?</strong></td>
      <td><strong>Yes.</strong> Clean Architecture enforces strict separation. Domain layer has zero Compose imports. Could switch to native UI per platform.</td>
      <td><strong>Mostly yes.</strong> Zustand stores and TanStack queries are UI-framework agnostic. But hooks mix presentation concerns with data access.</td>
    </tr>
    <tr>
      <td><strong>Is core logic portable?</strong></td>
      <td><strong>Highly portable.</strong> Kotlin compiles to JVM (server), JS (web), Native (iOS/macOS/Windows/Linux). Same code runs everywhere.</td>
      <td><strong>Portable within JS ecosystem.</strong> TypeScript compiles to JS only. Cannot share with JVM/Native backends without rewriting.</td>
    </tr>
    <tr>
      <td><strong>Incremental migration path</strong></td>
      <td>Can embed Compose views in native apps (Android: ComposeView, iOS: UIViewControllerRepresentable). Gradual adoption possible.</td>
      <td>Can embed RN views in native apps (ReactRootView). Brownfield integration well-documented.</td>
    </tr>
    <tr>
      <td><strong>Risk of vendor lock-in</strong></td>
      <td>Low: Kotlin is open-source (Apache 2.0). JetBrains+Google dual backing. Domain code is standard Kotlin.</td>
      <td>Low-Medium: React is open-source (MIT). But React Native specific APIs (TurboModules, Fabric) create platform coupling.</td>
    </tr>
  </table>
</section>

<!-- 26. COST CONSIDERATIONS -->
<section id="cost">
  <h2>26. Cost Considerations</h2>

  <table class="comparison-table">
    <tr>
      <th>Cost Factor</th>
      <th class="kmp-header">KMP</th>
      <th class="rn-header">RN</th>
    </tr>
    <tr>
      <td><strong>Build Infrastructure</strong></td>
      <td>JVM builds on any OS/architecture. iOS/macOS require macOS runners. Gradle build cache reduces CI costs.</td>
      <td>JS builds on any OS. iOS requires macOS. Android builds on Linux. Turborepo cache helps.</td>
    </tr>
    <tr>
      <td><strong>CI Time Cost</strong></td>
      <td>~10&ndash;15 min per full build. Gradle incremental builds save time on PRs.</td>
      <td>~8&ndash;12 min with change detection. Faster JS-only changes; slower native changes.</td>
    </tr>
    <tr>
      <td><strong>macOS Requirement</strong></td>
      <td>Required for: iOS framework, macOS DMG, Kotlin/Native compilation</td>
      <td>Required for: iOS builds only</td>
    </tr>
    <tr>
      <td><strong>Licensing</strong></td>
      <td>All open source (Apache 2.0 / MIT). IntelliJ Community is free. Android Studio is free.</td>
      <td>All open source (MIT / Apache 2.0). VS Code is free.</td>
    </tr>
    <tr>
      <td><strong>Developer Cost</strong></td>
      <td>1 Kotlin developer can target all 6 platforms. Smaller team needed for shared codebase.</td>
      <td>Need TS developers + native specialists for TurboModules. Potentially larger team.</td>
    </tr>
    <tr>
      <td><strong>App Store Limitations</strong></td>
      <td>None: Kotlin/Native produces standard iOS frameworks. No known rejections.</td>
      <td>None: React Native apps are standard native apps. Widely accepted.</td>
    </tr>
  </table>
</section>

<div class="page-break"></div>

<!-- 27. COMPREHENSIVE COMPARISON SUMMARY -->
<section id="summary">
  <h2>27. Comprehensive Comparison Summary</h2>

  <table class="comparison-table" style="font-size: 0.85em;">
    <tr>
      <th style="width:25%">Dimension</th>
      <th class="kmp-header" style="width:35%">Kotlin Multiplatform</th>
      <th class="rn-header" style="width:35%">React Native</th>
      <th style="width:5%">Edge</th>
    </tr>
    <tr>
      <td>Language Performance</td>
      <td>Compiled to native (iOS), JVM JIT (Android/Desktop)</td>
      <td>Interpreted (Hermes bytecode), 5&ndash;10x slower for CPU tasks</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Type Safety</td>
      <td>Null safety + sealed types + compile-time verification</td>
      <td>TypeScript strict mode, types erased at runtime</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Architecture</td>
      <td>Clean Architecture + MVVM with Koin DI</td>
      <td>Layered with Zustand/Query, no formal DI</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Testing</td>
      <td>Unit + Integration + Screenshot (Paparazzi) + Smoke</td>
      <td>Unit + Integration (Jest). No screenshot/E2E</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>PDF/Canvas Performance</td>
      <td>Skia direct rendering, zero bridge for drawing</td>
      <td>Bridge to native canvas, CanvasKit experimental</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Platform Coverage</td>
      <td>6 targets (incl. Wasm) from single codebase</td>
      <td>4 targets (Electron for desktop = Chromium overhead)</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Native API Access</td>
      <td>expect/actual: compile-time enforced, zero overhead</td>
      <td>TurboModules: runtime bridge, ~5&ndash;10 files per module</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Multi-threading</td>
      <td>Coroutines with dispatchers on all platforms</td>
      <td>Single JS thread; native threads via TurboModules only</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Backend Code Sharing</td>
      <td>Direct: Kotlin JVM libraries shared with Spring Boot</td>
      <td>None: TypeScript cannot share code with JVM backend</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Hot Reload / DX</td>
      <td>Limited hot reload; excellent IDE (IntelliJ)</td>
      <td>Excellent Fast Refresh; good VS Code support</td>
      <td><span class="badge badge-rn">RN</span></td>
    </tr>
    <tr>
      <td>Hiring Market</td>
      <td>~150K KMP developers (growing)</td>
      <td>~1M+ React Native developers</td>
      <td><span class="badge badge-rn">RN</span></td>
    </tr>
    <tr>
      <td>Observability</td>
      <td>Clean abstractions, fewer concrete integrations</td>
      <td>Full infra package: logging, crash, APM, A/B, remote config</td>
      <td><span class="badge badge-rn">RN</span></td>
    </tr>
    <tr>
      <td>Security Implementation</td>
      <td>Platform-native, offline-first</td>
      <td>Keychain/Keystore, JWT, auth flow, Semgrep</td>
      <td><span class="badge badge-rn">RN</span></td>
    </tr>
    <tr>
      <td>Monorepo Maturity</td>
      <td>2 Gradle modules (can be split further)</td>
      <td>12 pnpm packages with Turborepo orchestration</td>
      <td><span class="badge badge-rn">RN</span></td>
    </tr>
    <tr>
      <td>i18n</td>
      <td>15 languages, compile-time safe string access</td>
      <td>15 languages, runtime string keys</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Database (cross-platform)</td>
      <td>SQLDelight: type-safe, reactive, all 6 platforms</td>
      <td>WCDB: mobile only, no web database support</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Design System</td>
      <td>Complete tokens + 42 previews + theme system</td>
      <td>Complete tokens + theme provider + styled-components</td>
      <td><span class="badge badge-tie">Tie</span></td>
    </tr>
    <tr>
      <td>AI Resilience</td>
      <td>Compiler catches AI hallucinations before runtime</td>
      <td>Type erasure means AI errors may surface only at runtime</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Binary Size</td>
      <td>Smaller on mobile (~8&ndash;15MB). Desktop ~40MB.</td>
      <td>Larger on mobile (~15&ndash;25MB). Desktop ~120&ndash;150MB (Electron).</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Startup Time</td>
      <td>Faster: compiled code, no bundle parsing</td>
      <td>Slower: Hermes bytecode + RN bridge initialization</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
    <tr>
      <td>Memory Consumption</td>
      <td>Lower: ~15&ndash;25MB base, no JS runtime overhead</td>
      <td>Higher: ~30&ndash;50MB base with Hermes + RN runtime</td>
      <td><span class="badge badge-kmp">KMP</span></td>
    </tr>
  </table>

  <h3>Final Score</h3>
  <div style="display:flex;gap:24px;margin:20px 0;justify-content:center;">
    <div style="text-align:center;padding:24px 40px;background:linear-gradient(135deg, #7B61FF22, #7B61FF11);border-radius:16px;border:2px solid var(--kmp-color);">
      <div style="font-size:0.85em;text-transform:uppercase;letter-spacing:1px;color:var(--kmp-color);font-weight:600;">Kotlin Multiplatform</div>
      <div style="font-size:3em;font-weight:800;color:var(--kmp-color);">4.10</div>
      <div style="font-size:0.85em;color:var(--text-secondary);">/ 5.00 weighted</div>
    </div>
    <div style="text-align:center;padding:24px 40px;background:linear-gradient(135deg, #61DAFB22, #61DAFB11);border-radius:16px;border:2px solid var(--rn-color);">
      <div style="font-size:0.85em;text-transform:uppercase;letter-spacing:1px;color:#0891b2;font-weight:600;">React Native</div>
      <div style="font-size:3em;font-weight:800;color:#0891b2;">3.15</div>
      <div style="font-size:0.85em;color:var(--text-secondary);">/ 5.00 weighted</div>
    </div>
  </div>
</section>

<!-- FINAL RECOMMENDATION -->
<section id="recommendation">
  <h2>28. Recommendation</h2>
  <div class="executive-summary">
    <h3>For a Document Editing Application: Choose Kotlin Multiplatform</h3>
    <p>
      The performance characteristics of Kotlin Multiplatform&mdash;compiled-to-native execution, Skia-based rendering with zero bridge overhead, true multi-threading via coroutines, and direct native API access&mdash;make it the clear choice for an application that must handle PDF rendering, real-time canvas drawing with stylus input, and on-device ML inference.
    </p>
    <p>
      While React Native excels in developer experience and has a larger ecosystem, its fundamental architecture (single-threaded JS engine, bridge-based native communication, type erasure at runtime) creates performance ceilings that are difficult to overcome for the specific workloads a document editor demands.
    </p>
    <h4>When React Native might be preferred instead:</h4>
    <ul>
      <li>Content-centric apps (social media, e-commerce, news) where native rendering performance is less critical</li>
      <li>Teams with strong JavaScript/React expertise and limited Kotlin experience</li>
      <li>Projects prioritizing time-to-market over long-term performance optimization</li>
      <li>Applications where the majority of business logic is server-side</li>
    </ul>

    <h4>Key risks to monitor for KMP:</h4>
    <ul>
      <li>Compose Multiplatform for iOS is still maturing (production-ready since 2024, but less battle-tested than React Native)</li>
      <li>Smaller hiring pool requires investment in training and knowledge sharing</li>
      <li>Fewer community libraries than the npm ecosystem; some gaps may require custom implementations</li>
      <li>Gradle build times can be slower than Metro/Vite for JS-only changes</li>
    </ul>
  </div>
</section>

</div>

<div class="footer">
  <p>Generated by Claude Code &bull; February 20, 2026 &bull; PetShelter Engineering</p>
  <p style="font-size:0.8em;">This report compares two specific repository implementations. Technology platforms evolve rapidly; reassess periodically.</p>
</div>

</body>
</html>
